diff -urN vlc-0.2.61.org/Makefile.in vlc-0.2.61/Makefile.in
--- vlc-0.2.61.org/Makefile.in	Sun Feb 18 12:34:33 2001
+++ vlc-0.2.61/Makefile.in	Sun Feb 18 12:53:51 2001
@@ -300,7 +300,6 @@
 		plugins/esd/aout_esd.o
 
 PLUGIN_FB =	plugins/fb/fb.o \
-		plugins/fb/intf_fb.o \
 		plugins/fb/vout_fb.o
 
 PLUGIN_GGI =	plugins/ggi/ggi.o \
diff -urN vlc-0.2.61.org/plugins/fb/fb.c vlc-0.2.61/plugins/fb/fb.c
--- vlc-0.2.61.org/plugins/fb/fb.c	Sun Feb 18 12:34:32 2001
+++ vlc-0.2.61/plugins/fb/fb.c	Sun Feb 18 11:24:20 2001
@@ -1,10 +1,10 @@
 /*****************************************************************************
- * fb.c : Linux framebuffer plugin for vlc
+ * fb.c : framebuffer plugin for vlc
  *****************************************************************************
- * Copyright (C) 2000 VideoLAN
- *
- * Authors:
+ * Copyright (C) 2000, 2001 VideoLAN
  *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *      
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -20,118 +20,93 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
  *****************************************************************************/
 
+#define MODULE_NAME fb
+
 /*****************************************************************************
  * Preamble
  *****************************************************************************/
 #include "defs.h"
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
 #include <stdlib.h>                                      /* malloc(), free() */
-#include <unistd.h>                                               /* close() */
 
 #include "config.h"
 #include "common.h"                                     /* boolean_t, byte_t */
 #include "threads.h"
 #include "mtime.h"
-#include "tests.h"
-#include "plugins.h"
 
-#include "interface.h"
-#include "audio_output.h"
 #include "video.h"
 #include "video_output.h"
 
-#include "main.h"
+#include "modules.h"
+#include "modules_inner.h"
 
 /*****************************************************************************
- * Exported prototypes
+ * Building configuration tree
  *****************************************************************************/
-static void vout_GetPlugin( p_vout_thread_t p_vout );
-static void intf_GetPlugin( p_intf_thread_t p_intf );
-
-/* Video output */
-int     vout_FBCreate       ( vout_thread_t *p_vout, char *psz_display,
-                              int i_root_window, void *p_data );
-int     vout_FBInit         ( p_vout_thread_t p_vout );
-void    vout_FBEnd          ( p_vout_thread_t p_vout );
-void    vout_FBDestroy      ( p_vout_thread_t p_vout );
-int     vout_FBManage       ( p_vout_thread_t p_vout );
-void    vout_FBDisplay      ( p_vout_thread_t p_vout );
-void    vout_FBSetPalette   ( p_vout_thread_t p_vout,
-                              u16 *red, u16 *green, u16 *blue, u16 *transp );
+MODULE_CONFIG_START
+ADD_WINDOW( "Configuration for framebuffer module" )
+    ADD_COMMENT( "For now, the framebuffer module cannot be configured" )
+MODULE_CONFIG_END
 
-/* Interface */
-int     intf_FBCreate       ( p_intf_thread_t p_intf );
-void    intf_FBDestroy      ( p_intf_thread_t p_intf );
-void    intf_FBManage       ( p_intf_thread_t p_intf );
+/*****************************************************************************
+ * Capabilities defined in the other files.
+ ******************************************************************************/
+extern void vout_getfunctions( function_list_t * p_function_list );
 
 /*****************************************************************************
- * GetConfig: get the plugin structure and configuration
+ * InitModule: get the module structure and configuration.
+ *****************************************************************************
+ * We have to fill psz_name, psz_longname and psz_version. These variables
+ * will be strdup()ed later by the main application because the module can
+ * be unloaded later to save memory, and we want to be able to access this
+ * data even after the module has been unloaded.
  *****************************************************************************/
-plugin_info_t * GetConfig( void )
+int InitModule( module_t * p_module )
 {
-    int i_fd;
-    plugin_info_t * p_info = (plugin_info_t *) malloc( sizeof(plugin_info_t) );
+    p_module->psz_name = MODULE_STRING;
+    p_module->psz_longname = "Linux console framebuffer module";
+    p_module->psz_version = VERSION;
 
-    p_info->psz_name    = "Linux framebuffer";
-    p_info->psz_version = VERSION;
-    p_info->psz_author  = "the VideoLAN team <vlc@videolan.org>";
-
-    p_info->aout_GetPlugin = NULL;
-    p_info->vout_GetPlugin = vout_GetPlugin;
-    p_info->intf_GetPlugin = intf_GetPlugin;
-    p_info->yuv_GetPlugin  = NULL;
-
-    /* Test if the device can be opened */
-    if ( (i_fd = open( main_GetPszVariable( VOUT_FB_DEV_VAR,
-                                            VOUT_FB_DEV_DEFAULT ),
-                       O_RDWR )) < 0 )
-    {
-        p_info->i_score = 0;
-    }
-    else
-    {
-        close( i_fd );
-        p_info->i_score = 0x100;
-    }
+    p_module->i_capabilities = MODULE_CAPABILITY_NULL
+                                | MODULE_CAPABILITY_VOUT;
 
-    if( TestProgram( "fbvlc" ) )
-    {
-        p_info->i_score += 0x180;
-    }
+    return( 0 );
+}
 
-    /* If this plugin was requested, score it higher */
-    if( TestMethod( VOUT_METHOD_VAR, "fb" ) )
+/*****************************************************************************
+ * ActivateModule: set the module to an usable state.
+ *****************************************************************************
+ * This function fills the capability functions and the configuration
+ * structure. Once ActivateModule() has been called, the i_usage can
+ * be set to 0 and calls to NeedModule() be made to increment it. To unload
+ * the module, one has to wait until i_usage == 0 and call DeactivateModule().
+ *****************************************************************************/
+int ActivateModule( module_t * p_module )
+{
+    p_module->p_functions = malloc( sizeof( module_functions_t ) );
+    if( p_module->p_functions == NULL )
     {
-        p_info->i_score += 0x200;
+        return( -1 );
     }
 
-    return( p_info );
+    vout_getfunctions( &p_module->p_functions->vout );
+
+    p_module->p_config = p_config;
+
+    return( 0 );
 }
 
 /*****************************************************************************
- * Following functions are only called through the p_info structure
+ * DeactivateModule: make sure the module can be unloaded.
+ *****************************************************************************
+ * This function must only be called when i_usage == 0. If it successfully
+ * returns, i_usage can be set to -1 and the module unloaded. Be careful to
+ * lock usage_lock during the whole process.
  *****************************************************************************/
-
-static void vout_GetPlugin( p_vout_thread_t p_vout )
+int DeactivateModule( module_t * p_module )
 {
-    p_vout->p_sys_create  = vout_FBCreate;
-    p_vout->p_sys_init    = vout_FBInit;
-    p_vout->p_sys_end     = vout_FBEnd;
-    p_vout->p_sys_destroy = vout_FBDestroy;
-    p_vout->p_sys_manage  = vout_FBManage;
-    p_vout->p_sys_display = vout_FBDisplay;
-    
-    /* optional functions */
-    p_vout->p_set_palette = vout_FBSetPalette;
-}
+    free( p_module->p_functions );
 
-static void intf_GetPlugin( p_intf_thread_t p_intf )
-{
-    p_intf->p_sys_create  = intf_FBCreate;
-    p_intf->p_sys_destroy = intf_FBDestroy;
-    p_intf->p_sys_manage  = intf_FBManage;
+    return( 0 );
 }
 
diff -urN vlc-0.2.61.org/plugins/fb/intf_fb.c vlc-0.2.61/plugins/fb/intf_fb.c
--- vlc-0.2.61.org/plugins/fb/intf_fb.c	Sun Feb 18 12:34:32 2001
+++ vlc-0.2.61/plugins/fb/intf_fb.c	Thu Jan  1 01:00:00 1970
@@ -1,306 +0,0 @@
-/*****************************************************************************
- * intf_fb.c: Linux framebuffer interface plugin
- *****************************************************************************
- * Copyright (C) 2000 VideoLAN
- * $Id$
- *
- * Authors:
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
- *****************************************************************************/
-
-/*****************************************************************************
- * Preamble
- *****************************************************************************/
-#include "defs.h"
-
-#include <errno.h>                                                  /* errno */
-#include <signal.h>                                      /* SIGUSR1, SIGUSR2 */
-#include <stdlib.h>                                                /* free() */
-#include <string.h>                                            /* strerror() */
-#include <unistd.h>                                                /* read() */
-#include <sys/ioctl.h>                                            /* ioctl() */
-
-#include <termios.h>                                       /* struct termios */
-#include <linux/vt.h>                                                /* VT_* */
-#include <linux/kd.h>                                                 /* KD* */
-
-#include "config.h"
-#include "common.h"
-#include "threads.h"
-#include "mtime.h"
-#include "plugins.h"
-
-#include "stream_control.h"
-#include "input_ext-intf.h"
-
-#include "video.h"
-#include "video_output.h"
-
-#include "intf_msg.h"
-#include "interface.h"
-
-#include "main.h"
-
-/*****************************************************************************
- * intf_sys_t: description and status of FB interface
- *****************************************************************************/
-typedef struct intf_sys_s
-{
-    /* System informations */
-    int                         i_tty_dev;              /* tty device handle */
-
-    /* Original configuration informations */
-    struct sigaction            sig_usr1;           /* USR1 previous handler */
-    struct sigaction            sig_usr2;           /* USR2 previous handler */
-    struct vt_mode              vt_mode;                 /* previous VT mode */
-
-    int                 i_width;                     /* width of main window */
-    int                 i_height;                   /* height of main window */
-
-    struct termios      old_termios;
-    struct termios      new_termios;
-
-} intf_sys_t;
-
-/*****************************************************************************
- * Local prototypes
- *****************************************************************************/
-static void    FBSwitchDisplay            ( int i_signal );
-static void    FBTextMode                 ( int i_tty_dev );
-static void    FBGfxMode                  ( int i_tty_dev );
-
-/*****************************************************************************
- * intf_FBCreate: initialize and create window
- *****************************************************************************/
-int intf_FBCreate( intf_thread_t *p_intf )
-{
-    struct sigaction            sig_tty;         /* sigaction for tty change */
-    struct vt_mode              vt_mode;                  /* vt current mode */
-
-    /* Allocate instance and initialize some members */
-    p_intf->p_sys = malloc( sizeof( intf_sys_t ) );
-    if( p_intf->p_sys == NULL )
-    {
-        return( 1 );
-    };
-
-    /* Set tty and fb devices */
-    p_intf->p_sys->i_tty_dev = 0;       /* 0 == /dev/tty0 == current console */
-
-    FBGfxMode( p_intf->p_sys->i_tty_dev );
-
-    /* set keyboard settings */
-    if (tcgetattr(0, &p_intf->p_sys->old_termios) == -1)
-    {
-        intf_ErrMsg( "intf error: tcgetattr" );
-    }
-
-    if (tcgetattr(0, &p_intf->p_sys->new_termios) == -1)
-    {
-        intf_ErrMsg( "intf error: tcgetattr" );
-    }
-
-    p_intf->p_sys->new_termios.c_lflag &= ~ (ICANON | ISIG);
-    p_intf->p_sys->new_termios.c_lflag |= (ECHO | ECHOCTL);
-    p_intf->p_sys->new_termios.c_iflag = 0;
-    p_intf->p_sys->new_termios.c_cc[VMIN] = 1;
-    p_intf->p_sys->new_termios.c_cc[VTIME] = 0;
-
-    if (tcsetattr(0, TCSAFLUSH, &p_intf->p_sys->new_termios) == -1)
-    {
-        intf_ErrMsg( "intf error: tcsetattr" );
-    }
-
-    ioctl(p_intf->p_sys->i_tty_dev, VT_RELDISP, VT_ACKACQ);
-
-    /* Set-up tty signal handler to be aware of tty changes */
-    memset( &sig_tty, 0, sizeof( sig_tty ) );
-    sig_tty.sa_handler = FBSwitchDisplay;
-    sigemptyset( &sig_tty.sa_mask );
-    if( sigaction( SIGUSR1, &sig_tty, &p_intf->p_sys->sig_usr1 ) ||
-        sigaction( SIGUSR2, &sig_tty, &p_intf->p_sys->sig_usr2 ) )
-    {
-        intf_ErrMsg( "intf error: can't set up signal handler (%s)",
-                     strerror(errno) );
-        tcsetattr(0, 0, &p_intf->p_sys->old_termios);
-        FBTextMode( p_intf->p_sys->i_tty_dev );
-        return( 1 );
-    }
-
-    /* Set-up tty according to new signal handler */
-    if( ioctl(p_intf->p_sys->i_tty_dev, VT_GETMODE, &p_intf->p_sys->vt_mode)
-        == -1 )
-    {
-        intf_ErrMsg( "intf error: cant get terminal mode (%s)",
-                     strerror(errno) );
-        sigaction( SIGUSR1, &p_intf->p_sys->sig_usr1, NULL );
-        sigaction( SIGUSR2, &p_intf->p_sys->sig_usr2, NULL );
-        tcsetattr(0, 0, &p_intf->p_sys->old_termios);
-        FBTextMode( p_intf->p_sys->i_tty_dev );
-        return( 1 );
-    }
-    memcpy( &vt_mode, &p_intf->p_sys->vt_mode, sizeof( vt_mode ) );
-    vt_mode.mode   = VT_PROCESS;
-    vt_mode.waitv  = 0;
-    vt_mode.relsig = SIGUSR1;
-    vt_mode.acqsig = SIGUSR2;
-
-    if( ioctl(p_intf->p_sys->i_tty_dev, VT_SETMODE, &vt_mode) == -1 )
-    {
-        intf_ErrMsg( "intf error: can't set terminal mode (%s)",
-                     strerror(errno) );
-        sigaction( SIGUSR1, &p_intf->p_sys->sig_usr1, NULL );
-        sigaction( SIGUSR2, &p_intf->p_sys->sig_usr2, NULL );
-        tcsetattr(0, 0, &p_intf->p_sys->old_termios);
-        FBTextMode( p_intf->p_sys->i_tty_dev );
-        return( 1 );
-    }
-
-    /* Spawn video output thread */
-    if( p_main->b_video )
-    {
-        p_intf->p_vout = vout_CreateThread( NULL, 0,
-                                            p_intf->p_sys->i_width,
-                                            p_intf->p_sys->i_height,
-                                            NULL, 0, NULL );
-        if( p_intf->p_vout == NULL )                          /* XXX?? error */
-        {
-            intf_ErrMsg("intf error: can't create output thread" );
-            ioctl( p_intf->p_sys->i_tty_dev, VT_SETMODE,
-                   &p_intf->p_sys->vt_mode );
-            sigaction( SIGUSR1, &p_intf->p_sys->sig_usr1, NULL );
-            sigaction( SIGUSR2, &p_intf->p_sys->sig_usr2, NULL );
-            free( p_intf->p_sys );
-            tcsetattr(0, 0, &p_intf->p_sys->old_termios);
-            FBTextMode( p_intf->p_sys->i_tty_dev );
-            return( 1 );
-        }
-    }
-    
-    /* bind keys */
-    intf_AssignNormalKeys( p_intf );
-    
-    return( 0 );
-}
-
-/*****************************************************************************
- * intf_FBDestroy: destroy interface window
- *****************************************************************************/
-void intf_FBDestroy( intf_thread_t *p_intf )
-{
-    /* resets the keyboard state */
-    tcsetattr(0, 0, &p_intf->p_sys->old_termios);
-
-    /* return to text mode */
-    FBTextMode( p_intf->p_sys->i_tty_dev );
-
-    /* Close input thread, if any (blocking) */
-    if( p_intf->p_input )
-    {
-        input_DestroyThread( p_intf->p_input, NULL );
-    }
-
-    /* Close video output thread, if any (blocking) */
-    if( p_intf->p_vout )
-    {
-        vout_DestroyThread( p_intf->p_vout, NULL );
-    }
-
-    /* Destroy structure */
-    free( p_intf->p_sys );
-}
-
-
-/*****************************************************************************
- * intf_FBManage: event loop
- *****************************************************************************/
-void intf_FBManage( intf_thread_t *p_intf )
-{
-    unsigned char buf[16];
-
-    //while ( read(0, buf, 1) == 1)
-    if ( read(0, buf, 1) == 1)
-    {
-        if( intf_ProcessKey(p_intf, (int)buf[0]) )
-        {
-            intf_ErrMsg("unhandled key '%c' (%i)", (char) buf[0], buf[0] );
-        }
-    }
-}
-
-/*****************************************************************************
- * FBSwitchDisplay: VT change signal handler
- *****************************************************************************
- * This function activates or deactivates the output of the thread. It is
- * called by the VT driver, on terminal change.
- *****************************************************************************/
-static void FBSwitchDisplay(int i_signal)
-{
-    if( p_main->p_intf->p_vout != NULL )
-    {
-        switch( i_signal )
-        {
-        case SIGUSR1:                                /* vt has been released */
-            p_main->p_intf->p_vout->b_active = 0;
-            ioctl( ((intf_sys_t *)p_main->p_intf->p_sys)->i_tty_dev,
-                   VT_RELDISP, 1 );
-            break;
-        case SIGUSR2:                                /* vt has been acquired */
-            p_main->p_intf->p_vout->b_active = 1;
-            ioctl( ((intf_sys_t *)p_main->p_intf->p_sys)->i_tty_dev,
-                   VT_RELDISP, VT_ACTIVATE );
-            /* handle blanking */
-            p_main->p_intf->p_vout->i_changes |= VOUT_SIZE_CHANGE;
-            break;
-        }
-    }
-}
-
-/*****************************************************************************
- * FBTextMode and FBGfxMode : switch tty to text/graphic mode
- *****************************************************************************
- * These functions toggle the tty mode.
- *****************************************************************************/
-static void FBTextMode( int i_tty_dev )
-{
-    /* return to text mode */
-    if (-1 == ioctl(i_tty_dev, KDSETMODE, KD_TEXT))
-    {
-        intf_ErrMsg("intf error: ioctl KDSETMODE");
-    }
-}
-
-static void FBGfxMode( int i_tty_dev )
-{
-    /* switch to graphic mode */
-    if (-1 == ioctl(i_tty_dev, KDSETMODE, KD_GRAPHICS))
-    {
-        intf_ErrMsg("intf error: ioctl KDSETMODE");
-    }
-}
-
-/*****************************************************************************
- * vout_SysPrint: print simple text on a picture
- *****************************************************************************
- * This function will print a simple text on the picture. It is designed to
- * print debugging or general informations, not to render subtitles.
- *****************************************************************************/
-void vout_SysPrint( vout_thread_t *p_vout, int i_x, int i_y, int i_halign,
-                    int i_valign, unsigned char *psz_text )
-{
-
-}
-
diff -urN vlc-0.2.61.org/plugins/fb/vout_fb.c vlc-0.2.61/plugins/fb/vout_fb.c
--- vlc-0.2.61.org/plugins/fb/vout_fb.c	Sun Feb 18 12:34:32 2001
+++ vlc-0.2.61/plugins/fb/vout_fb.c	Sun Feb 18 11:24:20 2001
@@ -1,9 +1,9 @@
 /*****************************************************************************
- * vout_fb.c: Linux framebuffer video output display method
+ * vout_fb.c: framebuffer video output display method
  *****************************************************************************
- * Copyright (C) 1999, 2000 VideoLAN
+ * Copyright (C) 1998, 1999, 2000, 2001 VideoLAN
  *
- * Authors:
+ * Authors: Samuel Hocevar <sam@zoy.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,20 +26,26 @@
 #include "defs.h"
 
 #include <errno.h>                                                 /* ENOMEM */
+#include <signal.h>                                      /* SIGUSR1, SIGUSR2 */
 #include <stdlib.h>                                                /* free() */
 #include <string.h>                                            /* strerror() */
-
 #include <fcntl.h>                                                 /* open() */
 #include <unistd.h>                                               /* close() */
-#include <linux/fb.h>
+
+#include <termios.h>                                       /* struct termios */
 #include <sys/ioctl.h>
 #include <sys/mman.h>                                              /* mmap() */
 
+#include <linux/fb.h>
+#include <linux/vt.h>                                                /* VT_* */
+#include <linux/kd.h>                                                 /* KD* */
+
 #include "config.h"
 #include "common.h"
 #include "threads.h"
 #include "mtime.h"
-#include "plugins.h"
+#include "tests.h"
+#include "modules.h"
 
 #include "video.h"
 #include "video_output.h"
@@ -56,44 +62,191 @@
 typedef struct vout_sys_s
 {
     /* System informations */
-    int                         i_fb_dev;       /* framebuffer device handle */
-    struct fb_var_screeninfo    var_info;   /* framebuffer mode informations */
+    int                 i_tty_dev;                      /* tty device handle */
+    struct termios      old_termios;
+
+    /* Original configuration informations */
+    struct sigaction            sig_usr1;           /* USR1 previous handler */
+    struct sigaction            sig_usr2;           /* USR2 previous handler */
+    struct vt_mode              vt_mode;                 /* previous VT mode */
+
+    /* Framebuffer information */
+    int                         i_fb_dev;                   /* device handle */
+    struct fb_var_screeninfo    old_info;      /* original mode informations */
+    struct fb_var_screeninfo    var_info;       /* current mode informations */
+    boolean_t                   b_pan;     /* does device supports panning ? */
+    struct fb_cmap              fb_cmap;                /* original colormap */
+    u16                         *fb_palette;             /* original palette */
 
     /* Video memory */
     byte_t *                    p_video;                      /* base adress */
     size_t                      i_page_size;                    /* page size */
 
-    struct fb_cmap              fb_cmap;                /* original colormap */
-    unsigned short              *fb_palette;             /* original palette */
-
 } vout_sys_t;
 
 /*****************************************************************************
- * Local prototypes
+ * Local prototypes.
+ *****************************************************************************/
+static int  vout_Probe     ( probedata_t *p_data );
+static int  vout_Create    ( struct vout_thread_s * );
+static int  vout_Init      ( struct vout_thread_s * );
+static void vout_End       ( struct vout_thread_s * );
+static void vout_Destroy   ( struct vout_thread_s * );
+static int  vout_Manage    ( struct vout_thread_s * );
+static void vout_Display   ( struct vout_thread_s * );
+static void vout_SetPalette( p_vout_thread_t p_vout, u16 *red, u16 *green,
+                             u16 *blue, u16 *transp );
+
+static int  FBOpenDisplay  ( struct vout_thread_s * );
+static void FBCloseDisplay ( struct vout_thread_s * );
+static void FBSwitchDisplay( int i_signal );
+static void FBTextMode     ( int i_tty_dev );
+static void FBGfxMode      ( int i_tty_dev );
+
+/*****************************************************************************
+ * Functions exported as capabilities. They are declared as static so that
+ * we don't pollute the namespace too much.
+ *****************************************************************************/
+void vout_getfunctions( function_list_t * p_function_list )
+{
+    p_function_list->pf_probe = vout_Probe;
+    p_function_list->functions.vout.pf_create     = vout_Create;
+    p_function_list->functions.vout.pf_init       = vout_Init;
+    p_function_list->functions.vout.pf_end        = vout_End;
+    p_function_list->functions.vout.pf_destroy    = vout_Destroy;
+    p_function_list->functions.vout.pf_manage     = vout_Manage;
+    p_function_list->functions.vout.pf_display    = vout_Display;
+    p_function_list->functions.vout.pf_setpalette = vout_SetPalette;
+}
+
+/*****************************************************************************
+ * vout_Probe: probe the video driver and return a score
+ *****************************************************************************
+ * This function tries to open the framebuffer and returns a score to the
+ * plugin manager so that it can select the best plugin.
  *****************************************************************************/
-static int     FBOpenDisplay   ( vout_thread_t *p_vout );
-static void    FBCloseDisplay  ( vout_thread_t *p_vout );
+static int vout_Probe( probedata_t *p_data )
+{
+    int i_fd;
+
+    if( TestMethod( VOUT_METHOD_VAR, "fb" ) )
+    {
+        return( 999 );
+    }
+
+    i_fd = open( main_GetPszVariable( VOUT_FB_DEV_VAR,
+                                      VOUT_FB_DEV_DEFAULT ), O_RDWR );
+    if( i_fd == -1 )
+    {
+        return( 0 );
+    }
+    close( i_fd );
+
+    return( 30 );
+}
 
 /*****************************************************************************
- * vout_FBCreate: allocates FB video thread output method
+ * vout_Create: allocates FB video thread output method
  *****************************************************************************
  * This function allocates and initializes a FB vout method.
  *****************************************************************************/
-int vout_FBCreate( vout_thread_t *p_vout, char *psz_display,
-                    int i_root_window, void *p_data )
+static int vout_Create( vout_thread_t *p_vout )
 {
-    /* Allocate structure */
+    struct sigaction    sig_tty;                 /* sigaction for tty change */
+    struct vt_mode      vt_mode;                          /* vt current mode */
+    struct termios      new_termios;
+
+    /* Allocate instance and initialize some members */
     p_vout->p_sys = malloc( sizeof( vout_sys_t ) );
     if( p_vout->p_sys == NULL )
     {
-        intf_ErrMsg("error: %s", strerror(ENOMEM) );
+        return( 1 );
+    };
+
+    /* Set tty and fb devices */
+    p_vout->p_sys->i_tty_dev = 0;       /* 0 == /dev/tty0 == current console */
+
+    FBGfxMode( p_vout->p_sys->i_tty_dev );
+
+    /* Set keyboard settings */
+    if (tcgetattr(0, &p_vout->p_sys->old_termios) == -1)
+    {
+        intf_ErrMsg( "intf error: tcgetattr" );
+    }
+
+    if (tcgetattr(0, &new_termios) == -1)
+    {
+        intf_ErrMsg( "intf error: tcgetattr" );
+    }
+
+ /* new_termios.c_lflag &= ~ (ICANON | ISIG);
+    new_termios.c_lflag |= (ECHO | ECHOCTL); */
+    new_termios.c_lflag &= ~ (ICANON);
+    new_termios.c_lflag &= ~(ECHO | ECHOCTL);
+    new_termios.c_iflag = 0;
+    new_termios.c_cc[VMIN] = 1;
+    new_termios.c_cc[VTIME] = 0;
+
+    if (tcsetattr(0, TCSAFLUSH, &new_termios) == -1)
+    {
+        intf_ErrMsg( "intf error: tcsetattr" );
+    }
+
+    ioctl(p_vout->p_sys->i_tty_dev, VT_RELDISP, VT_ACKACQ);
+
+    /* Set-up tty signal handler to be aware of tty changes */
+    memset( &sig_tty, 0, sizeof( sig_tty ) );
+    sig_tty.sa_handler = FBSwitchDisplay;
+    sigemptyset( &sig_tty.sa_mask );
+    if( sigaction( SIGUSR1, &sig_tty, &p_vout->p_sys->sig_usr1 ) ||
+        sigaction( SIGUSR2, &sig_tty, &p_vout->p_sys->sig_usr2 ) )
+    {
+        intf_ErrMsg( "intf error: can't set up signal handler (%s)",
+                     strerror(errno) );
+        tcsetattr(0, 0, &p_vout->p_sys->old_termios);
+        FBTextMode( p_vout->p_sys->i_tty_dev );
+        free( p_vout->p_sys );
+        return( 1 );
+    }
+
+    /* Set-up tty according to new signal handler */
+    if( ioctl(p_vout->p_sys->i_tty_dev, VT_GETMODE, &p_vout->p_sys->vt_mode)
+        == -1 )
+    {
+        intf_ErrMsg( "intf error: cant get terminal mode (%s)",
+                     strerror(errno) );
+        sigaction( SIGUSR1, &p_vout->p_sys->sig_usr1, NULL );
+        sigaction( SIGUSR2, &p_vout->p_sys->sig_usr2, NULL );
+        tcsetattr(0, 0, &p_vout->p_sys->old_termios);
+        FBTextMode( p_vout->p_sys->i_tty_dev );
+        free( p_vout->p_sys );
+        return( 1 );
+    }
+    memcpy( &vt_mode, &p_vout->p_sys->vt_mode, sizeof( vt_mode ) );
+    vt_mode.mode   = VT_PROCESS;
+    vt_mode.waitv  = 0;
+    vt_mode.relsig = SIGUSR1;
+    vt_mode.acqsig = SIGUSR2;
+
+    if( ioctl(p_vout->p_sys->i_tty_dev, VT_SETMODE, &vt_mode) == -1 )
+    {
+        intf_ErrMsg( "intf error: can't set terminal mode (%s)",
+                     strerror(errno) );
+        sigaction( SIGUSR1, &p_vout->p_sys->sig_usr1, NULL );
+        sigaction( SIGUSR2, &p_vout->p_sys->sig_usr2, NULL );
+        tcsetattr(0, 0, &p_vout->p_sys->old_termios);
+        FBTextMode( p_vout->p_sys->i_tty_dev );
+        free( p_vout->p_sys );
         return( 1 );
     }
 
-    /* Open and initialize device */
     if( FBOpenDisplay( p_vout ) )
     {
-        intf_ErrMsg("vout error: can't open display");
+        ioctl(p_vout->p_sys->i_tty_dev, VT_SETMODE, &p_vout->p_sys->vt_mode);
+        sigaction( SIGUSR1, &p_vout->p_sys->sig_usr1, NULL );
+        sigaction( SIGUSR2, &p_vout->p_sys->sig_usr2, NULL );
+        tcsetattr(0, 0, &p_vout->p_sys->old_termios);
+        FBTextMode( p_vout->p_sys->i_tty_dev );
         free( p_vout->p_sys );
         return( 1 );
     }
@@ -102,63 +255,101 @@
 }
 
 /*****************************************************************************
- * vout_FBInit: initialize framebuffer video thread output method
+ * vout_Init: initialize framebuffer video thread output method
  *****************************************************************************/
-int vout_FBInit( vout_thread_t *p_vout )
+static int vout_Init( vout_thread_t *p_vout )
 {
+    /* Clear the screen */
+    memset( p_vout->p_sys->p_video, 0, p_vout->p_sys->i_page_size * 2 );
+
     return( 0 );
 }
 
 /*****************************************************************************
- * vout_FBEnd: terminate FB video thread output method
+ * vout_End: terminate framebuffer video thread output method
  *****************************************************************************/
-void vout_FBEnd( vout_thread_t *p_vout )
+static void vout_End( vout_thread_t *p_vout )
 {
-    ;
+    /* Clear the screen */
+    memset( p_vout->p_sys->p_video, 0, p_vout->p_sys->i_page_size * 2 );
 }
 
 /*****************************************************************************
- * vout_FBDestroy: destroy FB video thread output method
+ * vout_Destroy: destroy FB video thread output method
  *****************************************************************************
  * Terminate an output method created by vout_CreateOutputMethod
  *****************************************************************************/
-void vout_FBDestroy( vout_thread_t *p_vout )
+static void vout_Destroy( vout_thread_t *p_vout )
 {
     FBCloseDisplay( p_vout );
+
+    /* Reset the terminal */
+    ioctl(p_vout->p_sys->i_tty_dev, VT_SETMODE, &p_vout->p_sys->vt_mode);
+
+    /* Remove signal handlers */
+    sigaction( SIGUSR1, &p_vout->p_sys->sig_usr1, NULL );
+    sigaction( SIGUSR2, &p_vout->p_sys->sig_usr2, NULL );
+
+    /* Reset the keyboard state */
+    tcsetattr( 0, 0, &p_vout->p_sys->old_termios );
+
+    /* Return to text mode */
+    FBTextMode( p_vout->p_sys->i_tty_dev );
+
+    /* Destroy structure */
     free( p_vout->p_sys );
 }
 
 /*****************************************************************************
- * vout_FBManage: handle FB events
+ * vout_Manage: handle FB events
  *****************************************************************************
  * This function should be called regularly by video output thread. It manages
  * console events. It returns a non null value on error.
  *****************************************************************************/
-int vout_FBManage( vout_thread_t *p_vout )
+static int vout_Manage( vout_thread_t *p_vout )
 {
+#if 0
+    u8 buf;
+
+    if ( read(0, &buf, 1) == 1)
+    {
+        switch( buf )
+        {
+        case 'q':
+            p_main->p_intf->b_die = 1;
+            break;
+
+        default:
+            break;
+        }
+    }
+#endif
+
     /*
      * Size change
      */
     if( p_vout->i_changes & VOUT_SIZE_CHANGE )
     {
-        intf_DbgMsg("resizing window");
+        intf_WarnMsg( 1, "vout: reinitializing framebuffer screen" );
         p_vout->i_changes &= ~VOUT_SIZE_CHANGE;
 
         /* Destroy XImages to change their size */
-        vout_FBEnd( p_vout );
+        vout_End( p_vout );
 
         /* Recreate XImages. If SysInit failed, the thread can't go on. */
-        if( vout_FBInit( p_vout ) )
+        if( vout_Init( p_vout ) )
         {
-            intf_ErrMsg("error: can't resize display");
+            intf_ErrMsg("error: cannot reinit framebuffer screen" );
             return( 1 );
         }
 
+        /* Clear screen */
+        memset( p_vout->p_sys->p_video, 0, p_vout->p_sys->i_page_size * 2 );
+
 #if 1
         /* Tell the video output thread that it will need to rebuild YUV
          * tables. This is needed since conversion buffer size may have changed */
         p_vout->i_changes |= VOUT_YUV_CHANGE;
-        intf_Msg("vout: video display resized (%dx%d)", p_vout->i_width, p_vout->i_height);
 #endif
     }
 
@@ -166,56 +357,48 @@
 }
 
 /*****************************************************************************
- * vout_FBDisplay: displays previously rendered output
+ * vout_Display: displays previously rendered output
  *****************************************************************************
  * This function send the currently rendered image to FB image, waits until
  * it is displayed and switch the two rendering buffers, preparing next frame.
  *****************************************************************************/
-void vout_FBDisplay( vout_thread_t *p_vout )
+static void vout_Display( vout_thread_t *p_vout )
 {
-    /* swap the two Y offsets */
-    
-#ifdef FB_NOYPAN
-    
-    /* if the fb doesn't supports ypan, we only use one buffer */
-
-#else
-    p_vout->p_sys->var_info.yoffset = p_vout->i_buffer_index ? p_vout->p_sys->var_info.yres : 0;
+    /* swap the two Y offsets if the drivers supports panning */
+    if( p_vout->p_sys->b_pan )
+    {
+        p_vout->p_sys->var_info.yoffset =
+            p_vout->i_buffer_index ? p_vout->p_sys->var_info.yres : 0;
    
-    /* the X offset should be 0, but who knows ...
-     * some other app might have played with the framebuffer */
-    p_vout->p_sys->var_info.xoffset = 0;
+        /* the X offset should be 0, but who knows ...
+         * some other app might have played with the framebuffer */
+        p_vout->p_sys->var_info.xoffset = 0;
 
-    //ioctl( p_vout->p_sys->i_fb_dev, FBIOPUT_VSCREENINFO, &p_vout->p_sys->var_info );
-    ioctl( p_vout->p_sys->i_fb_dev, FBIOPAN_DISPLAY, &p_vout->p_sys->var_info );
-#endif
+        ioctl( p_vout->p_sys->i_fb_dev,
+               FBIOPAN_DISPLAY, &p_vout->p_sys->var_info );
+    }
 }
 
 /*****************************************************************************
- * vout_FBSetPalette: sets an 8 bpp palette
+ * vout_SetPalette: sets an 8 bpp palette
  *****************************************************************************
  * This function sets the palette given as an argument. It does not return
  * anything, but could later send information on which colors it was unable
  * to set.
  *****************************************************************************/
-void vout_FBSetPalette( p_vout_thread_t p_vout,
-                      u16 *red, u16 *green, u16 *blue, u16 *transp )
+static void vout_SetPalette( p_vout_thread_t p_vout,
+                             u16 *red, u16 *green, u16 *blue, u16 *transp )
 {
     struct fb_cmap cmap = { 0, 256, red, green, blue, transp };
+
     ioctl( p_vout->p_sys->i_fb_dev, FBIOPUTCMAP, &cmap );
 }
 
 /* following functions are local */
 
 /*****************************************************************************
- * FBOpenDisplay: open and initialize framebuffer device
- *****************************************************************************
- * XXX?? The framebuffer mode is only provided as a fast and efficient way to
- * display video, providing the card is configured and the mode ok. It is
- * not portable, and is not supposed to work with many cards. Use at your
- * own risk !
+ * FBOpenDisplay: initialize framebuffer
  *****************************************************************************/
-
 static int FBOpenDisplay( vout_thread_t *p_vout )
 {
     char *psz_device;                             /* framebuffer device path */
@@ -233,24 +416,26 @@
     /* Get framebuffer device informations */
     if( ioctl( p_vout->p_sys->i_fb_dev, FBIOGET_VSCREENINFO, &p_vout->p_sys->var_info ) )
     {
-        intf_ErrMsg( "vout error: can't get framebuffer informations (%s)", strerror(errno) );
+        intf_ErrMsg("vout error: can't get fb info (%s)", strerror(errno) );
         close( p_vout->p_sys->i_fb_dev );
         return( 1 );
     }
 
-    /* Framebuffer must have some basic properties to be usable */
-    /* XXX?? */
+    if( ioctl( p_vout->p_sys->i_fb_dev, FBIOGET_VSCREENINFO, &p_vout->p_sys->old_info ) )
+    {
+        intf_ErrMsg("vout error: can't get 2nd fb info (%s)", strerror(errno) );
+        close( p_vout->p_sys->i_fb_dev );
+        return( 1 );
+    }
 
     /* Set some attributes */
     p_vout->p_sys->var_info.activate = FB_ACTIVATE_NXTOPEN;
     p_vout->p_sys->var_info.xoffset =  0;
     p_vout->p_sys->var_info.yoffset =  0;
-    intf_ErrMsg( "vout: ypanstep is %i", fix_info.ypanstep );
-    /* XXX?? ask sam p_vout->p_sys->mode_info.sync = FB_SYNC_VERT_HIGH_ACT; */
 
     if( ioctl( p_vout->p_sys->i_fb_dev, FBIOPUT_VSCREENINFO, &p_vout->p_sys->var_info ) )
     {
-        intf_ErrMsg("vout error: can't set framebuffer informations (%s)", strerror(errno) );
+        intf_ErrMsg(" vout error: can't set fb info (%s)", strerror(errno) );
         close( p_vout->p_sys->i_fb_dev );
         return( 1 );
     }
@@ -259,30 +444,45 @@
     if( ioctl( p_vout->p_sys->i_fb_dev, FBIOGET_FSCREENINFO, &fix_info ) ||
         ioctl( p_vout->p_sys->i_fb_dev, FBIOGET_VSCREENINFO, &p_vout->p_sys->var_info ) )
     {
-        intf_ErrMsg("vout error: can't get framebuffer informations (%s)", strerror(errno) );
-        /* FIXME: restore fb config ?? */
+        intf_ErrMsg(" vout error: can't get additional fb info (%s)", strerror(errno) );
+
+        /* Restore fb config */
+        ioctl( p_vout->p_sys->i_fb_dev, FBIOPUT_VSCREENINFO, &p_vout->p_sys->var_info );
+
         close( p_vout->p_sys->i_fb_dev );
         return( 1 );
     }
 
     /* FIXME: if the image is full-size, it gets cropped on the left
      * because of the xres / xres_virtual slight difference */
-    intf_Msg( "vout: %ix%i (virtual %ix%i)", p_vout->p_sys->var_info.xres, p_vout->p_sys->var_info.yres, p_vout->p_sys->var_info.xres_virtual, p_vout->p_sys->var_info.yres_virtual );
-    p_vout->i_width =                   p_vout->p_sys->var_info.xres_virtual ? p_vout->p_sys->var_info.xres_virtual : p_vout->p_sys->var_info.xres;
-    p_vout->i_height =                  p_vout->p_sys->var_info.yres;
-    p_vout->i_screen_depth =            p_vout->p_sys->var_info.bits_per_pixel;
+    intf_WarnMsg( 1, "vout: %ix%i (virtual %ix%i)",
+                  p_vout->p_sys->var_info.xres,
+                  p_vout->p_sys->var_info.yres,
+                  p_vout->p_sys->var_info.xres_virtual,
+                  p_vout->p_sys->var_info.yres_virtual );
+
+    p_vout->i_height = p_vout->p_sys->var_info.yres;
+    p_vout->i_width  = p_vout->p_sys->var_info.xres_virtual ?
+                           p_vout->p_sys->var_info.xres_virtual
+                           : p_vout->p_sys->var_info.xres;
+
+    p_vout->i_screen_depth = p_vout->p_sys->var_info.bits_per_pixel;
+
+    p_vout->p_sys->fb_palette = NULL;
+    p_vout->p_sys->b_pan = ( fix_info.ypanstep || fix_info.ywrapstep );
+
     switch( p_vout->i_screen_depth )
     {
     case 8:                                                         /* 8 bpp */
-        p_vout->p_sys->fb_palette = malloc( 8 * 256 * sizeof(unsigned short) );
+        p_vout->p_sys->fb_palette = malloc( 8 * 256 * sizeof( u16 ) );
         p_vout->p_sys->fb_cmap.start = 0;
         p_vout->p_sys->fb_cmap.len = 256;
         p_vout->p_sys->fb_cmap.red = p_vout->p_sys->fb_palette;
-        p_vout->p_sys->fb_cmap.green = p_vout->p_sys->fb_palette + 256 * sizeof(unsigned short);
-        p_vout->p_sys->fb_cmap.blue = p_vout->p_sys->fb_palette + 2 * 256 * sizeof(unsigned short);
-        p_vout->p_sys->fb_cmap.transp = p_vout->p_sys->fb_palette + 3 * 256 * sizeof(unsigned short);
+        p_vout->p_sys->fb_cmap.green = p_vout->p_sys->fb_palette + 256 * sizeof( u16 );
+        p_vout->p_sys->fb_cmap.blue = p_vout->p_sys->fb_palette + 2 * 256 * sizeof( u16 );
+        p_vout->p_sys->fb_cmap.transp = p_vout->p_sys->fb_palette + 3 * 256 * sizeof( u16 );
 
-        /* saves the colormap */
+        /* Save the colormap */
         ioctl( p_vout->p_sys->i_fb_dev, FBIOGETCMAP, &p_vout->p_sys->fb_cmap );
 
         p_vout->i_bytes_per_pixel = 1;
@@ -308,6 +508,11 @@
     default:                                     /* unsupported screen depth */
         intf_ErrMsg( "vout error: screen depth %d is not supported",
                      p_vout->i_screen_depth);
+
+        /* Restore fb config */
+        ioctl( p_vout->p_sys->i_fb_dev, FBIOPUT_VSCREENINFO, &p_vout->p_sys->var_info );
+
+        close( p_vout->p_sys->i_fb_dev );
         return( 1 );
         break;
     }
@@ -330,39 +535,47 @@
                 p_vout->i_height * p_vout->i_bytes_per_pixel;
 
     /* Map two framebuffers a the very beginning of the fb */
-    p_vout->p_sys->p_video = mmap(0, p_vout->p_sys->i_page_size * 2,
-                          PROT_READ | PROT_WRITE, MAP_SHARED,
-                          p_vout->p_sys->i_fb_dev, 0 );
-    memset( p_vout->p_sys->p_video, 0, p_vout->p_sys->i_page_size * 2 );
-    if( (int)p_vout->p_sys->p_video == -1 ) /* according to man, it is -1. What about NULL ? */
+    p_vout->p_sys->p_video = mmap( 0, p_vout->p_sys->i_page_size * 2,
+                                   PROT_READ | PROT_WRITE, MAP_SHARED,
+                                   p_vout->p_sys->i_fb_dev, 0 );
+
+    if( (int)p_vout->p_sys->p_video == -1 ) /* according to man, it is -1.
+                                               What about NULL ? */
     {
         intf_ErrMsg("vout error: can't map video memory (%s)", strerror(errno) );
         /* FIXME: restore fb config ?? */
+        if( p_vout->i_screen_depth == 8 )
+        {
+            free( p_vout->p_sys->fb_palette );
+        }
+
+        /* Restore fb config */
+        ioctl( p_vout->p_sys->i_fb_dev, FBIOPUT_VSCREENINFO, &p_vout->p_sys->var_info );
+
         close( p_vout->p_sys->i_fb_dev );
         return( 1 );
     }
 
     /* Set and initialize buffers */
-
-    vout_SetBuffers( p_vout, p_vout->p_sys->p_video,
-
-#ifdef FB_NOYPAN /* If the fb doesn't support ypan */
-            p_vout->p_sys->p_video 
-#else
-            p_vout->p_sys->p_video + p_vout->p_sys->i_page_size 
-#endif
-                );
+    if( p_vout->p_sys->b_pan )
+    {
+        vout_SetBuffers( p_vout, p_vout->p_sys->p_video,
+                                 p_vout->p_sys->p_video
+                                  + p_vout->p_sys->i_page_size );
+    }
+    else
+    {
+        vout_SetBuffers( p_vout, p_vout->p_sys->p_video,
+                                 p_vout->p_sys->p_video );
+    }
     
-    intf_DbgMsg("framebuffer type=%d, visual=%d, ypanstep=%d, ywrap=%d, accel=%d",
-                fix_info.type, fix_info.visual, fix_info.ypanstep, fix_info.ywrapstep, fix_info.accel );
+    intf_WarnMsg( 1, "framebuffer type=%d, visual=%d, ypanstep=%d, ywrap=%d, accel=%d",
+                  fix_info.type, fix_info.visual, fix_info.ypanstep, fix_info.ywrapstep, fix_info.accel );
     return( 0 );
 }
 
 /*****************************************************************************
- * FBCloseDisplay: close and reset framebuffer device
- *****************************************************************************
- * Returns all resources allocated by FBOpenDisplay and restore the original
- * state of the device.
+ * FBCloseDisplay: terminate FB video thread output method
  *****************************************************************************/
 static void FBCloseDisplay( vout_thread_t *p_vout )
 {
@@ -376,8 +589,63 @@
         free( p_vout->p_sys->fb_palette );
     }
 
-    /* Destroy window and close display */
+    /* Restore fb config */
+    ioctl( p_vout->p_sys->i_fb_dev, FBIOPUT_VSCREENINFO, &p_vout->p_sys->var_info );
+
+    /* Close fb */
     close( p_vout->p_sys->i_fb_dev );
 }
 
+/*****************************************************************************
+ * FBSwitchDisplay: VT change signal handler
+ *****************************************************************************
+ * This function activates or deactivates the output of the thread. It is
+ * called by the VT driver, on terminal change.
+ *****************************************************************************/
+static void FBSwitchDisplay(int i_signal)
+{
+    if( p_main->p_vout != NULL )
+    {
+        switch( i_signal )
+        {
+        case SIGUSR1:                                /* vt has been released */
+            p_main->p_vout->b_active = 0;
+            ioctl( ((vout_sys_t *)p_main->p_vout->p_sys)->i_tty_dev,
+                   VT_RELDISP, 1 );
+            break;
+        case SIGUSR2:                                /* vt has been acquired */
+            p_main->p_vout->b_active = 1;
+            ioctl( ((vout_sys_t *)p_main->p_vout->p_sys)->i_tty_dev,
+                   VT_RELDISP, VT_ACTIVATE );
+            /* handle blanking */
+            vlc_mutex_lock( &p_main->p_vout->change_lock );
+            p_main->p_vout->i_changes |= VOUT_SIZE_CHANGE;
+            vlc_mutex_unlock( &p_main->p_vout->change_lock );
+            break;
+        }
+    }
+}
+
+/*****************************************************************************
+ * FBTextMode and FBGfxMode : switch tty to text/graphic mode
+ *****************************************************************************
+ * These functions toggle the tty mode.
+ *****************************************************************************/
+static void FBTextMode( int i_tty_dev )
+{
+    /* return to text mode */
+    if (-1 == ioctl(i_tty_dev, KDSETMODE, KD_TEXT))
+    {
+        intf_ErrMsg( "intf error: failed ioctl KDSETMODE KD_TEXT" );
+    }
+}
+
+static void FBGfxMode( int i_tty_dev )
+{
+    /* switch to graphic mode */
+    if (-1 == ioctl(i_tty_dev, KDSETMODE, KD_GRAPHICS))
+    {
+        intf_ErrMsg( "intf error: failed ioctl KDSETMODE KD_GRAPHICS" );
+    }
+}
 
